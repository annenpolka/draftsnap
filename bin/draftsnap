#!/usr/bin/env bash
set -euo pipefail

SCR_DIR=${DRAFTSNAP_SCR_DIR:-scratch}
GIT_DIR=${DRAFTSNAP_GIT_DIR:-.git-scratch}
WORK_TREE=${DRAFTSNAP_WORK_TREE:-.}
JSON=0
DEFAULT_MSG=""
LOCK_DIR="$GIT_DIR/.draftsnap.lock"
LOCK_HELD=0
ENSURE_INITIALIZED=false

fail() {
  echo "draftsnap: $*" >&2
  exit 1
}

log() {
  [[ $JSON -eq 1 ]] && return
  echo "$*" >&2
}

bool_json() {
  [[ "$1" == "true" ]] && printf 'true' || printf 'false'
}

git_side() {
  git --git-dir="$GIT_DIR" --work-tree="$WORK_TREE" "$@"
}

json_escape() {
  local s=${1:-}
  s=${s//\\/\\\\}
  s=${s//\"/\\\"}
  s=${s//$'\n'/\\n}
  s=${s//$'\r'/\\r}
  s=${s//$'\t'/\\t}
  printf '%s' "$s"
}

release_lock() {
  if [[ ${LOCK_HELD:-0} -eq 1 ]]; then
    rmdir "$LOCK_DIR" 2>/dev/null || true
    LOCK_HELD=0
  fi
}

acquire_lock() {
  if [[ ${LOCK_HELD:-0} -eq 1 ]]; then
    return 0
  fi
  mkdir -p "$(dirname "$LOCK_DIR")"
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    LOCK_HELD=1
    trap release_lock EXIT
    return 0
  fi
  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"error","code":12,"message":"locked"}\n'
  else
    echo "draftsnap: another process holds the lock" >&2
  fi
  exit 12
}

ensure_exclude_line() {
  local line="$1" file="$2"
  grep -Fxq "$line" "$file" 2>/dev/null && return
  printf '%s\n' "$line" >>"$file"
}

ensure_repo() {
  local initialized=false

  if [[ ! -d "$GIT_DIR" ]] || [[ ! -f "$GIT_DIR/HEAD" ]]; then
    git --git-dir="$GIT_DIR" --work-tree="$WORK_TREE" init --quiet
    initialized=true
  fi

  mkdir -p "$SCR_DIR"

  local exclude_file=".git/info/exclude"
  mkdir -p "$(dirname "$exclude_file")"
  touch "$exclude_file"
  ensure_exclude_line "$SCR_DIR/" "$exclude_file"
  ensure_exclude_line "$GIT_DIR/" "$exclude_file"

  local side_exclude="$GIT_DIR/info/exclude"
  mkdir -p "$(dirname "$side_exclude")"
  touch "$side_exclude"
  ensure_exclude_line "*" "$side_exclude"
  ensure_exclude_line "!$SCR_DIR/" "$side_exclude"
  ensure_exclude_line "!$SCR_DIR/**" "$side_exclude"

  ENSURE_INITIALIZED=$initialized
}

cmd_ensure() {
  acquire_lock
  ensure_repo
  local initialized=$ENSURE_INITIALIZED
  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"initialized":%s,"git_dir":"%s","scr_dir":"%s"}}\n' "$(bool_json "$initialized")" "$GIT_DIR" "$SCR_DIR"
  else
    log "ensure completed"
  fi
  release_lock
}

cmd_status() {
  local initialized=false
  [[ -d "$GIT_DIR" ]] && initialized=true

  local locked=false
  [[ -d "$LOCK_DIR" ]] && locked=true

  local main_exclude=".git/info/exclude"
  local main_git=false
  local main_scr=false
  if [[ -f "$main_exclude" ]]; then
    grep -Fxq "$GIT_DIR/" "$main_exclude" && main_git=true
    grep -Fxq "$SCR_DIR/" "$main_exclude" && main_scr=true
  fi

  local side_exclude="$GIT_DIR/info/exclude"
  local side_wild=false
  local side_scr=false
  local side_glob=false
  if [[ -f "$side_exclude" ]]; then
    grep -Fxq "*" "$side_exclude" && side_wild=true
    grep -Fxq "!$SCR_DIR/" "$side_exclude" && side_scr=true
    grep -Fxq "!$SCR_DIR/**" "$side_exclude" && side_glob=true
  fi

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":'
    printf '{"initialized":%s,' "$(bool_json "$initialized")"
    printf '"git_dir":"%s","scr_dir":"%s",' "$GIT_DIR" "$SCR_DIR"
    printf '"locked":%s,' "$(bool_json "$locked")"
    printf '"exclude":'
    printf '{"main":{"git_dir":%s,"scr_dir":%s},' \
      "$(bool_json "$main_git")" "$(bool_json "$main_scr")"
    printf '"sidecar":{"wildcard":%s,"scr_dir":%s,"scr_glob":%s}}' \
      "$(bool_json "$side_wild")" "$(bool_json "$side_scr")" "$(bool_json "$side_glob")"
    printf '}}\n'
  else
    log "initialized: $(bool_json "$initialized"), locked: $(bool_json "$locked")"
    log "main exclude - git_dir: $(bool_json "$main_git"), scr_dir: $(bool_json "$main_scr")"
    log "sidecar exclude - wildcard: $(bool_json "$side_wild"), scr_dir: $(bool_json "$side_scr"), scr_glob: $(bool_json "$side_glob")"
  fi
}

cmd_snap() {
  local path=""
  local message="$DEFAULT_MSG"
  local stdin_mode=false
  local space=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -m|--message)
        shift || fail "missing argument for -m"
        message="$1"
        ;;
      --space)
        shift || fail "missing argument for --space"
        space="$1"
        ;;
      --json)
        JSON=1
        ;;
      -)
        stdin_mode=true
        path="-"
        ;;
      *)
        path="$1"
        ;;
    esac
    shift || break
  done

  [[ -n "$path" ]] || fail "snap requires a target path"

  acquire_lock
  ensure_repo

  local target_path
  if [[ "$path" == "-" ]]; then
    local stream_name="stream-$(date +%Y%m%d%H%M%S).md"
    if [[ -n "$space" ]]; then
      target_path="$SCR_DIR/$space/$stream_name"
    else
      target_path="$SCR_DIR/$stream_name"
    fi
  else
    if [[ "$path" == /* ]]; then
      target_path="$path"
    elif [[ "$path" == "$SCR_DIR"/* ]]; then
      target_path="$path"
    elif [[ -n "$space" ]]; then
      target_path="$SCR_DIR/$space/$path"
    else
      target_path="$SCR_DIR/$path"
    fi
  fi

  local abs_path="$WORK_TREE/$target_path"
  mkdir -p "$(dirname "$abs_path")"

  if $stdin_mode; then
    cat >"$abs_path"
  elif [[ ! -f "$abs_path" ]]; then
    : >"$abs_path"
  fi

  git_side add -f "$target_path"

  if git_side diff --staged --quiet; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":10,"data":{"commit":null,"path":"%s","bytes":0}}\n' "$target_path"
    fi
    release_lock
    return 10
  fi

  local base_message=${message:-"snap: $target_path"}
  local final_message="$base_message"
  if [[ -n "$space" ]]; then
    final_message="[space:${space}] $base_message"
  fi
  git_side commit --quiet -m "$final_message"
  local commit_hash
  commit_hash=$(git_side rev-parse HEAD)
  local size
  size=$(wc -c <"$abs_path")
  size=${size//[[:space:]]/}

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"commit":"%s","path":"%s","bytes":%s}}\n' "$commit_hash" "$target_path" "$size"
  else
    log "snap stored $target_path at $commit_hash"
  fi
  release_lock
}

cmd_log() {
  if [[ ! -d "$GIT_DIR" ]] || [[ ! -f "$GIT_DIR/HEAD" ]]; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":0,"data":{"entries":[]}}'"\n"
    fi
    return 0
  fi

  if ! git_side rev-parse --verify HEAD >/dev/null 2>&1; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":0,"data":{"entries":[]}}\n'
    fi
    return 0
  fi

  local format=$'%H\x1f%ad\x1f%s'
  local log_output
  if ! log_output=$(git_side log --date=iso-strict --pretty=format:"$format" --name-only); then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"error","code":14,"message":"failed to read log"}\n'
    else
      echo "draftsnap: failed to read log" >&2
    fi
    return 14
  fi

  local entries_json="[]"
  local human_lines=()
  local commit="" timestamp="" subject="" filepath=""

  append_entry() {
    if [[ -z "$commit" ]]; then
      return
    fi
    local path="${filepath:-}"
    local json_entry
    json_entry=$(printf '{"commit":"%s","timestamp":"%s","message":"%s","path":"%s"}' \
      "$commit" "$(json_escape "$timestamp")" "$(json_escape "$subject")" "$(json_escape "$path")")
    if [[ "$entries_json" == "[]" ]]; then
      entries_json="[$json_entry]"
    else
      entries_json="${entries_json%]},"$json_entry"]"
    fi
    human_lines+=("$(printf '%s %s %s' "$commit" "$path" "$subject")")
  }

  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      append_entry
      commit="" timestamp="" subject="" filepath=""
      continue
    fi
    if [[ "$line" == *$'\x1f'* ]]; then
      IFS=$'\x1f' read -r commit timestamp subject <<<"$line"
      continue
    fi
    if [[ -z "$filepath" ]]; then
      filepath="$line"
    fi
  done <<<"$log_output"
  append_entry

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"entries":%s}}' "$entries_json"
    printf '\n'
  else
    if ((${#human_lines[@]})); then
      printf '%s\n' "${human_lines[@]}" | sed '/^$/d'
    fi
  fi
}

main() {
  local cmd=""
  local cmd_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        JSON=1
        ;;
      -m|--message)
        shift || fail "missing argument for -m"
        DEFAULT_MSG="$1"
        ;;
      --)
        shift
        cmd_args+=("$@")
        break
        ;;
      -* )
        cmd_args+=("$1")
        ;;
      *)
        if [[ -z "$cmd" ]]; then
          cmd="$1"
        else
          cmd_args+=("$1")
        fi
        ;;
    esac
    shift || break
  done

  case "$cmd" in
    ensure)
      if ((${#cmd_args[@]})); then
        cmd_ensure "${cmd_args[@]}"
      else
        cmd_ensure
      fi
      ;;
    status)
      if ((${#cmd_args[@]})); then
        cmd_status "${cmd_args[@]}"
      else
        cmd_status
      fi
      ;;
    log)
      if ((${#cmd_args[@]})); then
        cmd_log "${cmd_args[@]}"
      else
        cmd_log
      fi
      ;;
    snap)
      if ((${#cmd_args[@]})); then
        cmd_snap "${cmd_args[@]}"
      else
        cmd_snap
      fi
      ;;
    "")
      fail "no command specified"
      ;;
    *)
      fail "unknown command: $cmd"
      ;;
  esac
}

main "$@"
