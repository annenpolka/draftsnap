#!/usr/bin/env bash
set -euo pipefail

SCR_DIR=${DRAFTSNAP_SCR_DIR:-scratch}
GIT_DIR=${DRAFTSNAP_GIT_DIR:-.git-scratch}
WORK_TREE=${DRAFTSNAP_WORK_TREE:-.}
JSON=0
DEFAULT_MSG=""
LOCK_DIR="$GIT_DIR/.draftsnap.lock"
LOCK_HELD=0
ENSURE_INITIALIZED=false

fail() {
  echo "draftsnap: $*" >&2
  exit 1
}

log() {
  [[ $JSON -eq 1 ]] && return
  echo "$*" >&2
}

bool_json() {
  [[ "$1" == "true" ]] && printf 'true' || printf 'false'
}

git_side() {
  git --git-dir="$GIT_DIR" --work-tree="$WORK_TREE" "$@"
}

json_escape() {
  local s=${1:-}
  s=${s//\\/\\\\}
  s=${s//\"/\\\"}
  s=${s//$'\n'/\\n}
  s=${s//$'\r'/\\r}
  s=${s//$'\t'/\\t}
  printf '%s' "$s"
}

release_lock() {
  if [[ ${LOCK_HELD:-0} -eq 1 ]]; then
    rmdir "$LOCK_DIR" 2>/dev/null || true
    LOCK_HELD=0
  fi
}

acquire_lock() {
  if [[ ${LOCK_HELD:-0} -eq 1 ]]; then
    return 0
  fi
  mkdir -p "$(dirname "$LOCK_DIR")"
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    LOCK_HELD=1
    trap release_lock EXIT
    return 0
  fi
  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"error","code":12,"message":"locked"}\n'
  else
    echo "draftsnap: another process holds the lock" >&2
  fi
  exit 12
}

ensure_exclude_line() {
  local line="$1" file="$2"
  grep -Fxq "$line" "$file" 2>/dev/null && return
  printf '%s\n' "$line" >>"$file"
}

ensure_repo() {
  local initialized=false

  if [[ ! -d "$GIT_DIR" ]] || [[ ! -f "$GIT_DIR/HEAD" ]]; then
    git --git-dir="$GIT_DIR" --work-tree="$WORK_TREE" init --quiet
    initialized=true
  fi

  mkdir -p "$SCR_DIR"

  local exclude_file=".git/info/exclude"
  mkdir -p "$(dirname "$exclude_file")"
  touch "$exclude_file"
  ensure_exclude_line "$SCR_DIR/" "$exclude_file"
  ensure_exclude_line "$GIT_DIR/" "$exclude_file"

  local side_exclude="$GIT_DIR/info/exclude"
  mkdir -p "$(dirname "$side_exclude")"
  touch "$side_exclude"
  ensure_exclude_line "*" "$side_exclude"
  ensure_exclude_line "!$SCR_DIR/" "$side_exclude"
  ensure_exclude_line "!$SCR_DIR/**" "$side_exclude"

  ENSURE_INITIALIZED=$initialized
}

cmd_ensure() {
  acquire_lock
  ensure_repo
  local initialized=$ENSURE_INITIALIZED
  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"initialized":%s,"git_dir":"%s","scr_dir":"%s"}}\n' "$(bool_json "$initialized")" "$GIT_DIR" "$SCR_DIR"
  else
    log "ensure completed"
  fi
  release_lock
}

cmd_status() {
  local initialized=false
  [[ -d "$GIT_DIR" ]] && initialized=true

  local locked=false
  [[ -d "$LOCK_DIR" ]] && locked=true

  local main_exclude=".git/info/exclude"
  local main_git=false
  local main_scr=false
  if [[ -f "$main_exclude" ]]; then
    grep -Fxq "$GIT_DIR/" "$main_exclude" && main_git=true
    grep -Fxq "$SCR_DIR/" "$main_exclude" && main_scr=true
  fi

  local side_exclude="$GIT_DIR/info/exclude"
  local side_wild=false
  local side_scr=false
  local side_glob=false
  if [[ -f "$side_exclude" ]]; then
    grep -Fxq "*" "$side_exclude" && side_wild=true
    grep -Fxq "!$SCR_DIR/" "$side_exclude" && side_scr=true
    grep -Fxq "!$SCR_DIR/**" "$side_exclude" && side_glob=true
  fi

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":'
    printf '{"initialized":%s,' "$(bool_json "$initialized")"
    printf '"git_dir":"%s","scr_dir":"%s",' "$GIT_DIR" "$SCR_DIR"
    printf '"locked":%s,' "$(bool_json "$locked")"
    printf '"exclude":'
    printf '{"main":{"git_dir":%s,"scr_dir":%s},' \
      "$(bool_json "$main_git")" "$(bool_json "$main_scr")"
    printf '"sidecar":{"wildcard":%s,"scr_dir":%s,"scr_glob":%s}}' \
      "$(bool_json "$side_wild")" "$(bool_json "$side_scr")" "$(bool_json "$side_glob")"
    printf '}}\n'
  else
    log "initialized: $(bool_json "$initialized"), locked: $(bool_json "$locked")"
    log "main exclude - git_dir: $(bool_json "$main_git"), scr_dir: $(bool_json "$main_scr")"
    log "sidecar exclude - wildcard: $(bool_json "$side_wild"), scr_dir: $(bool_json "$side_scr"), scr_glob: $(bool_json "$side_glob")"
  fi
}

cmd_snap() {
  local path=""
  local message="$DEFAULT_MSG"
  local stdin_mode=false
  local space=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -m|--message)
        shift || fail "missing argument for -m"
        message="$1"
        ;;
      --space)
        shift || fail "missing argument for --space"
        space="$1"
        ;;
      --json)
        JSON=1
        ;;
      -)
        stdin_mode=true
        path="-"
        ;;
      *)
        path="$1"
        ;;
    esac
    shift || break
  done

  [[ -n "$path" ]] || fail "snap requires a target path"

  acquire_lock
  ensure_repo

  local target_path
  if [[ "$path" == "-" ]]; then
    local stream_name
    stream_name="stream-$(date +%Y%m%d%H%M%S).md"
    if [[ -n "$space" ]]; then
      target_path="$SCR_DIR/$space/$stream_name"
    else
      target_path="$SCR_DIR/$stream_name"
    fi
  else
    if [[ "$path" == /* ]]; then
      target_path="$path"
    elif [[ "$path" == "$SCR_DIR"/* ]]; then
      target_path="$path"
    elif [[ -n "$space" ]]; then
      target_path="$SCR_DIR/$space/$path"
    else
      target_path="$SCR_DIR/$path"
    fi
  fi

  local abs_path="$WORK_TREE/$target_path"
  mkdir -p "$(dirname "$abs_path")"

  if $stdin_mode; then
    cat >"$abs_path"
  elif [[ ! -f "$abs_path" ]]; then
    : >"$abs_path"
  fi

  git_side add -f "$target_path"

  if git_side diff --staged --quiet; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":10,"data":{"commit":null,"path":"%s","bytes":0}}\n' "$target_path"
    fi
    release_lock
    return 10
  fi

  local base_message=${message:-"snap: $target_path"}
  local final_message="$base_message"
  if [[ -n "$space" ]]; then
    final_message="[space:${space}] $base_message"
  fi
  git_side commit --quiet -m "$final_message"
  local commit_hash
  commit_hash=$(git_side rev-parse HEAD)
  local size
  size=$(wc -c <"$abs_path")
  size=${size//[[:space:]]/}

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"commit":"%s","path":"%s","bytes":%s}}\n' "$commit_hash" "$target_path" "$size"
  else
    log "snap stored $target_path at $commit_hash"
  fi
  release_lock
}

cmd_log() {
  if [[ ! -d "$GIT_DIR" ]] || [[ ! -f "$GIT_DIR/HEAD" ]]; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":0,"data":{"entries":[]}}'"\n"
    fi
    return 0
  fi

  if ! git_side rev-parse --verify HEAD >/dev/null 2>&1; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":0,"data":{"entries":[]}}\n'
    fi
    return 0
  fi

  local format=$'%H\x1f%ad\x1f%s'
  local log_output
  if ! log_output=$(git_side log --date=iso-strict --pretty=format:"$format" --name-only); then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"error","code":14,"message":"failed to read log"}\n'
    else
      echo "draftsnap: failed to read log" >&2
    fi
    return 14
  fi

  local entries_json="[]"
  local human_lines=()
  local commit="" timestamp="" subject="" filepath=""

  append_entry() {
    if [[ -z "$commit" ]]; then
      return
    fi
    local path="${filepath:-}"
    local json_entry
    json_entry=$(printf '{"commit":"%s","timestamp":"%s","message":"%s","path":"%s"}' \
      "$commit" "$(json_escape "$timestamp")" "$(json_escape "$subject")" "$(json_escape "$path")")
    if [[ "$entries_json" == "[]" ]]; then
      entries_json="[$json_entry]"
    else
      entries_json="${entries_json%]},$json_entry]"
    fi
    human_lines+=("$(printf '%s %s %s' "$commit" "$path" "$subject")")
  }

  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      append_entry
      commit="" timestamp="" subject="" filepath=""
      continue
    fi
    if [[ "$line" == *$'\x1f'* ]]; then
      IFS=$'\x1f' read -r commit timestamp subject <<<"$line"
      continue
    fi
    if [[ -z "$filepath" ]]; then
      filepath="$line"
    fi
  done <<<"$log_output"
  append_entry

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"entries":%s}}' "$entries_json"
    printf '\n'
  else
    if ((${#human_lines[@]})); then
      printf '%s\n' "${human_lines[@]}" | sed '/^$/d'
    fi
  fi
}

cmd_diff() {
  if ! git_side rev-parse --verify HEAD >/dev/null 2>&1; then
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":0,"data":{"basis":{"type":"none"},"entries":[]}}'"\n"
    fi
    return 0
  fi

  local since="" use_current=0
  local pathspec=()
  local args=("$@")
  local i=0
  while [[ $i -lt ${#args[@]} ]]; do
    local token=${args[$i]}
    case "$token" in
      --since)
        ((i++))
        if [[ $i -ge ${#args[@]} ]]; then
          fail "--since requires an argument"
        fi
        since=${args[$i]}
        ;;
      --current)
        use_current=1
        ;;
      --)
        ((i++))
        while [[ $i -lt ${#args[@]} ]]; do
          pathspec+=("${args[$i]}")
          ((i++))
        done
        break
        ;;
      *)
        pathspec+=("$token")
        ;;
    esac
    ((i++))
  done

  local diff_args=()
  local basis_type="" basis_new="" basis_old="" basis_since=""

  if [[ $use_current -eq 1 ]]; then
    basis_type="current"
    basis_new="working"
    basis_old=$(git_side rev-parse HEAD)
    diff_args=(HEAD)
  else
    local head_commit
    head_commit=$(git_side rev-parse HEAD)
    local offset=${since:-1}
    if [[ -z "$since" ]]; then
      # require at least two commits
      if ! git_side rev-parse HEAD^ >/dev/null 2>&1; then
        if [[ $JSON -eq 1 ]]; then
          printf '{"status":"ok","code":0,"data":{"basis":{"type":"latest_pair","new":"%s","old":null},"entries":[]}}\n' "$head_commit"
        fi
        return 0
      fi
      basis_type="latest_pair"
    else
      if ! [[ "$offset" =~ ^[0-9]+$ ]]; then
        fail "--since expects a non-negative integer"
      fi
      if [[ "$offset" -lt 1 ]]; then
        fail "--since must be >= 1"
      fi
      basis_type="since"
      basis_since="$offset"
    fi

    local base_ref
    if ! base_ref=$(git_side rev-parse "HEAD~$offset" 2>/dev/null); then
      if [[ $JSON -eq 1 ]]; then
        printf '{"status":"ok","code":0,"data":{"basis":{"type":"%s","new":"%s","old":null},"entries":[]}}\n' "$basis_type" "$head_commit"
      fi
      return 0
    fi

    basis_new="$head_commit"
    basis_old="$base_ref"
    diff_args=("$base_ref" "$head_commit")
  fi

  if ((${#pathspec[@]})); then
    diff_args+=(-- "${pathspec[@]}")
  fi

  local numstat_output
  if [[ $use_current -eq 1 ]]; then
    numstat_output=$(git_side diff --numstat "${diff_args[@]}" || true)
  else
    numstat_output=$(git_side diff --numstat "${diff_args[@]}" || true)
  fi

  local entries_json="[]"
  local human_lines=()
  if [[ -n "$numstat_output" ]]; then
    while IFS=$'\t' read -r added removed file; do
      [[ -z "$file" ]] && continue
      [[ "$added" == "-" ]] && added=0
      [[ "$removed" == "-" ]] && removed=0
      local entry_json
      entry_json=$(printf '{"path":"%s","added":%s,"removed":%s}' "$(json_escape "$file")" "$added" "$removed")
      if [[ "$entries_json" == "[]" ]]; then
        entries_json="[$entry_json]"
      else
        entries_json="${entries_json%]},$entry_json]"
      fi
      human_lines+=("$(printf '%s +%s -%s' "$file" "$added" "$removed")")
    done <<<"$numstat_output"
  fi

  local diff_patch
  if [[ $use_current -eq 1 ]]; then
    diff_patch=$(git_side diff "${diff_args[@]}")
  else
    diff_patch=$(git_side diff "${diff_args[@]}")
  fi

  if [[ $JSON -eq 1 ]]; then
    local basis_json='{"type":"'"$basis_type"'"}'
    case "$basis_type" in
      latest_pair)
        basis_json=$(printf '{"type":"latest_pair","new":"%s","old":"%s"}' "$basis_new" "$basis_old")
        ;;
      since)
        basis_json=$(printf '{"type":"since","since":%s,"new":"%s","old":"%s"}' "$basis_since" "$basis_new" "$basis_old")
        ;;
      current)
        basis_json=$(printf '{"type":"current","new":"%s","old":"%s"}' "$basis_new" "$basis_old")
        ;;
    esac
    printf '{"status":"ok","code":0,"data":{"basis":%s,"entries":%s,"patch":"%s"}}\n' \
      "$basis_json" "$entries_json" "$(json_escape "$diff_patch")"
  else
    if [[ -n "$diff_patch" ]]; then
      printf '%s\n' "$diff_patch"
    else
      # fall back to stats if no patch
      if ((${#human_lines[@]})); then
        printf '%s\n' "${human_lines[@]}"
      fi
    fi
  fi
}

cmd_restore() {
  local rev=""
  local path=""
  local args=("$@")
  local i=0
  while [[ $i -lt ${#args[@]} ]]; do
    local token=${args[$i]}
    if [[ "$token" == "--" ]]; then
      ((i++))
      continue
    fi
    if [[ -z "$rev" ]]; then
      rev="$token"
    elif [[ -z "$path" ]]; then
      path="$token"
    else
      fail "unexpected argument: $token"
    fi
    ((i++))
  done

  [[ -n "$rev" ]] || fail "restore requires a revision"
  [[ -n "$path" ]] || fail "restore requires -- <path>"

  acquire_lock
  ensure_repo

  local rev_sha
  if ! rev_sha=$(git_side rev-parse --verify "$rev" 2>/dev/null); then
    release_lock
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"error","code":14,"message":"unknown revision: %s"}\n' "$(json_escape "$rev")"
    else
      echo "draftsnap: unknown revision: $rev" >&2
    fi
    exit 14
  fi

  local tmpfile
  tmpfile=$(mktemp)
  if ! git_side show "${rev_sha}:${path}" >"$tmpfile" 2>/dev/null; then
    rm -f "$tmpfile"
    release_lock
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"error","code":14,"message":"path not found in revision"}\n'
    else
      echo "draftsnap: path not found in revision" >&2
    fi
    exit 14
  fi

  local dest="$WORK_TREE/$path"
  mkdir -p "$(dirname "$dest")"

  local backup=""
  if [[ -f "$dest" ]]; then
    if ! cmp -s "$dest" "$tmpfile"; then
      backup="${dest}.draftsnap.bak.$(date +%Y%m%d%H%M%S)"
      cp "$dest" "$backup"
    fi
  fi

  mv "$tmpfile" "$dest"

  local bytes
  bytes=$(wc -c <"$dest")
  bytes=${bytes//[[:space:]]/}

  local warnings_json="[]"
  local human_warn=()
  if [[ -n "$backup" ]]; then
    warnings_json=$(printf '["%s"]' "$(json_escape "existing file differed; backup stored at $backup")")
    human_warn+=("backup saved to $backup")
  fi

  release_lock

  if [[ $JSON -eq 1 ]]; then
    local backup_json
    if [[ -n "$backup" ]]; then
      backup_json="\"$(json_escape "$backup")\""
    else
      backup_json="null"
    fi
    printf '{"status":"ok","code":0,"data":{"path":"%s","bytes":%s,"rev":"%s","backup":%s},"warnings":%s}\n' \
      "$(json_escape "$path")" "$bytes" "$rev_sha" "$backup_json" "$warnings_json"
  else
    echo "restored $path from $rev_sha"
    if ((${#human_warn[@]})); then
      printf '%s\n' "${human_warn[@]}" >&2
    fi
  fi
}

cmd_help() {
  local format="txt"
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --format)
        shift || fail "missing value for --format"
        format="$1"
        ;;
      --format=*)
        format="${1#--format=}"
        ;;
      --json)
        JSON=1
        format="json"
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift || break
  done

  [[ ${#args[@]} -eq 0 ]] || fail "help does not accept positional arguments"
  [[ "$format" =~ ^(txt|text|json)$ ]] || fail "unsupported format: $format"

  local usage="Usage: draftsnap <command> [options]"
  local commands=(
    "ensure|Initialize or verify the draftsnap sidecar"
    "status|Report initialization and lock status"
    "snap|Capture a snapshot from a file or stdin"
    "diff|Compare recent snapshots or the working tree"
    "log|List snapshots with metadata"
    "restore|Restore a file from a prior snapshot"
    "prune|Trim old snapshots, optionally archiving"
    "help|Show this summary"
    "prompt|Emit agent guidance"
  )
  local globals=(
    "--json|Emit JSON on STDOUT"
    "--dry-run|Describe actions without modifying the sidecar"
    "--quiet|Suppress most human-oriented logs"
    "--debug|Emit verbose diagnostic output"
  )
  local exits=(
    "0|Success"
    "10|Success (no changes)"
    "11|Not initialized"
    "12|Locked"
    "13|Precondition failed"
    "14|Invalid arguments"
  )

  if [[ $JSON -eq 1 || "$format" == "json" ]]; then
    local cmds_json="["
    local desc_json="{"
    local first=1
    for entry in "${commands[@]}"; do
      IFS='|' read -r name desc <<<"$entry"
      if [[ $first -eq 0 ]]; then
        cmds_json+=","
        desc_json+=","
      fi
      cmds_json+="\"$(json_escape "$name")\""
      desc_json+="\"$(json_escape "$name")\":\"$(json_escape "$desc")\""
      first=0
    done
    cmds_json+="]"
    desc_json+="}"

    local globals_json="["
    first=1
    for entry in "${globals[@]}"; do
      IFS='|' read -r flag desc <<<"$entry"
      if [[ $first -eq 0 ]]; then
        globals_json+=","
      fi
      globals_json+="{\"flag\":\"$(json_escape "$flag")\",\"description\":\"$(json_escape "$desc")\"}"
      first=0
    done
    globals_json+="]"

    local exit_json="{"
    first=1
    for entry in "${exits[@]}"; do
      IFS='|' read -r code desc <<<"$entry"
      if [[ $first -eq 0 ]]; then
        exit_json+=","
      fi
      exit_json+="\"$code\":\"$(json_escape "$desc")\""
      first=0
    done
    exit_json+="}"

    printf '{"status":"ok","code":0,"data":{"usage":"%s","commands":%s,"descriptions":%s,"global_options":%s,"exit_codes":%s}}\n' \
      "$(json_escape "$usage")" "$cmds_json" "$desc_json" "$globals_json" "$exit_json"
  else
    printf '%s\n\nCommands:\n' "$usage"
    for entry in "${commands[@]}"; do
      IFS='|' read -r name desc <<<"$entry"
      printf '  %-8s %s\n' "$name" "$desc"
    done
    printf '\nGlobal options:\n'
    for entry in "${globals[@]}"; do
      IFS='|' read -r flag desc <<<"$entry"
      printf '  %-10s %s\n' "$flag" "$desc"
    done
    printf '\nExit codes:\n'
    for entry in "${exits[@]}"; do
      IFS='|' read -r code desc <<<"$entry"
      printf '  %-3s %s\n' "$code" "$desc"
    done
    printf '\nSee %sdraftsnap prompt --json%s for agent-oriented guidance.\n' '`' '`'
  fi
}

cmd_prompt() {
  local instructions=$'You may optionally use a CLI tool named “draftsnap” to manage temporary drafts (e.g., Markdown notes) in a sidecar Git repository. Your role is not fixed to “document manager”; use this tool only when it helps your current task.\n\nBasic rules:\n1) Once per session, run `draftsnap ensure --json`. It idempotently prepares a local sidecar repo, creates the scratch directory, and sets `.git/info/exclude`. Proceed only if it returns JSON with code 0.\n2) When you create or edit a temporary draft under the configured scratch directory (default: `scratch/`), snapshot it with:\n   `draftsnap snap <path> -m "<short reason>" --json`\n   Treat exit code 0 as committed. Treat exit code 10 as “no changes” (still a success).\n3) Parse only STDOUT as JSON (`--json`). Never parse STDERR; it is human-oriented logs.\n4) To review or roll back, you may call:\n   - `draftsnap log --json [-- <path>]` to list history,\n   - `draftsnap diff [REV] --json [-- <path>]` to inspect changes,\n   - `draftsnap restore <REV> -- <path> --json` to restore content into the working tree.\n5) For periodic cleanup, you may run `draftsnap prune --keep 200 --json` (or `--days N`). Use it sparingly.\n6) Do not modify `.gitignore`; drafts are excluded locally via `.git/info/exclude`. The tool never pushes to any remote.\n7) If `draftsnap` is unavailable, continue your task without it; do not block.\n\nMessage convention for `-m`:\nUse a terse “purpose: summary” style, e.g., `purpose: tighten outline`, so commits are searchable.\n\nReturn handling:\n- Success with commit: `{"status":"ok","code":0,...}`\n- Success with no changes: `{"status":"ok","code":10,...}`\n- Precondition or lock errors are non-fatal to your overall task; you may retry later.\n\nExample:\n- Start: `draftsnap ensure --json`\n- After writing `scratch/idea.md`: `draftsnap snap scratch/idea.md -m "purpose: refine intro" --json`\n\nUse the tool when it reduces risk or friction; otherwise proceed normally.'

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"instructions":"%s"}}\n' "$(json_escape "$instructions")"
  else
    printf '%s\n' "$instructions"
  fi
}

cmd_prune() {
  local keep=""
  local archive=""
  local args=()

  while [[ $# -gt 0 ]]; do
    local token="$1"
    shift
    case "$token" in
      --keep)
        [[ $# -gt 0 ]] || fail "missing value for --keep"
        keep="$1"
        shift
        ;;
      --archive)
        [[ $# -gt 0 ]] || fail "missing directory for --archive"
        archive="$1"
        shift
        ;;
      --json)
        JSON=1
        ;;
      --)
        args+=("$@")
        break
        ;;
      *)
        args+=("$token")
        ;;
    esac
  done

  [[ ${#args[@]} -eq 0 ]] || fail "prune does not accept positional arguments"
  [[ -n "$keep" ]] || fail "--keep is required"
  if ! [[ "$keep" =~ ^[0-9]+$ ]]; then
    fail "--keep must be a non-negative integer"
  fi
  if [[ "$keep" -lt 1 ]]; then
    fail "--keep must be >= 1"
  fi

  acquire_lock
  ensure_repo

  if ! git_side rev-parse --verify HEAD >/dev/null 2>&1; then
    release_lock
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":10,"data":{"kept":0,"removed":0,"archive":null,"removed_commits":[]},"warnings":["nothing to prune"]}\n'
    else
      log "nothing to prune"
    fi
    return 10
  fi

  local commits=()
  while IFS= read -r commit_line; do
    commits+=("$commit_line")
  done < <(git_side rev-list --reverse HEAD)
  local total=${#commits[@]}
  if [[ "$total" -le "$keep" ]]; then
    release_lock
    if [[ $JSON -eq 1 ]]; then
      printf '{"status":"ok","code":10,"data":{"kept":%s,"removed":0,"archive":null,"removed_commits":[]},"warnings":["already within threshold"]}\n' "$total"
    else
      log "already within threshold"
    fi
    return 10
  fi

  local remove_count=$((total - keep))
  local -a removed_commits=()
  local idx=0
  while [[ $idx -lt $remove_count ]]; do
    removed_commits+=("${commits[$idx]}")
    ((idx++))
  done

  local archive_dir=""
  if [[ -n "$archive" ]]; then
    archive_dir="$WORK_TREE/$archive"
    mkdir -p "$archive_dir"
    local counter=0
    for sha in "${removed_commits[@]}"; do
      local short=${sha:0:7}
      local out="$archive_dir/$((counter+1))-$short.tar"
      git_side archive "$sha" -o "$out"
      ((counter++))
    done
  fi

  local depth=$keep
  local tmpdir
  tmpdir=$(mktemp -d)
  local source_path
  source_path=$(cd "$GIT_DIR"/.. && pwd)/$(basename "$GIT_DIR")
  if ! git clone --quiet --depth "$depth" "file://$source_path" "$tmpdir/clone"; then
    rm -rf "$tmpdir"
    release_lock
    fail "failed to clone sidecar for pruning"
  fi

  local backup_git
  backup_git="$GIT_DIR.prune.bak.$(date +%s)"
  mv "$GIT_DIR" "$backup_git"
  mv "$tmpdir/clone/.git" "$GIT_DIR"
  rm -rf "$tmpdir/clone"
  rm -rf "$tmpdir"
  rm -rf "$backup_git"

  ensure_repo
  git_side reset --hard >/dev/null 2>&1 || true
  git_side remote remove origin >/dev/null 2>&1 || true

  release_lock

  local removed_json="[]"
  if ((${#removed_commits[@]})); then
    local first=1
    removed_json="["
    for sha in "${removed_commits[@]}"; do
      if [[ $first -eq 0 ]]; then
        removed_json+=",";
      fi
      removed_json+="\"$(json_escape "$sha")\""
      first=0
    done
    removed_json+="]"
  fi

  local archive_json
  if [[ -n "$archive_dir" ]]; then
    archive_json="\"$(json_escape "$archive_dir")\""
  else
    archive_json="null"
  fi

  if [[ $JSON -eq 1 ]]; then
    printf '{"status":"ok","code":0,"data":{"kept":%s,"removed":%s,"archive":%s,"removed_commits":%s}}\n' \
      "$keep" "$remove_count" "$archive_json" "$removed_json"
  else
    log "pruned $remove_count commits (kept $keep)"
  fi
}

main() {
  local cmd=""
  local cmd_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)
        JSON=1
        ;;
      -m|--message)
        shift || fail "missing argument for -m"
        DEFAULT_MSG="$1"
        ;;
      --)
        shift
        cmd_args+=("$@")
        break
        ;;
      -* )
        cmd_args+=("$1")
        ;;
      *)
        if [[ -z "$cmd" ]]; then
          cmd="$1"
        else
          cmd_args+=("$1")
        fi
        ;;
    esac
    shift || break
  done

  case "$cmd" in
    ensure)
      if ((${#cmd_args[@]})); then
        cmd_ensure "${cmd_args[@]}"
      else
        cmd_ensure
      fi
      ;;
    status)
      if ((${#cmd_args[@]})); then
        cmd_status "${cmd_args[@]}"
      else
        cmd_status
      fi
      ;;
    prune)
      if ((${#cmd_args[@]})); then
        cmd_prune "${cmd_args[@]}"
      else
        cmd_prune
      fi
      ;;
    help)
      if ((${#cmd_args[@]})); then
        cmd_help "${cmd_args[@]}"
      else
        cmd_help
      fi
      ;;
    prompt)
      if ((${#cmd_args[@]})); then
        cmd_prompt "${cmd_args[@]}"
      else
        cmd_prompt
      fi
      ;;
    diff)
      if ((${#cmd_args[@]})); then
        cmd_diff "${cmd_args[@]}"
      else
        cmd_diff
      fi
      ;;
    log)
      if ((${#cmd_args[@]})); then
        cmd_log "${cmd_args[@]}"
      else
        cmd_log
      fi
      ;;
    restore)
      if ((${#cmd_args[@]})); then
        cmd_restore "${cmd_args[@]}"
      else
        cmd_restore
      fi
      ;;
    snap)
      if ((${#cmd_args[@]})); then
        cmd_snap "${cmd_args[@]}"
      else
        cmd_snap
      fi
      ;;
    "")
      fail "no command specified"
      ;;
    *)
      fail "unknown command: $cmd"
      ;;
  esac
}

main "$@"
